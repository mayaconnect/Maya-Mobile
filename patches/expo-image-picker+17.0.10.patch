diff --git a/node_modules/expo-image-picker/ios/ImagePickerHandler.swift b/node_modules/expo-image-picker/ios/ImagePickerHandler.swift
index 476910d..98a2252 100644
--- a/node_modules/expo-image-picker/ios/ImagePickerHandler.swift
+++ b/node_modules/expo-image-picker/ios/ImagePickerHandler.swift
@@ -6,6 +6,7 @@ import PhotosUI
  Protocol that describes scenarios we care about while the user is picking media.
  */
 protocol OnMediaPickingResultHandler {
+  @available(iOS 14.0, *)
   func didPickMultipleMedia(selection: [PHPickerResult])
   func didPickMedia(mediaInfo: MediaInfo)
   func didCancelPicking()
@@ -21,7 +22,6 @@ protocol OnMediaPickingResultHandler {
  2) it separates some logic from the main module class and hopefully makes it cleaner.
  */
 internal class ImagePickerHandler: NSObject,
-                                   PHPickerViewControllerDelegate,
                                    UINavigationControllerDelegate,
                                    UIImagePickerControllerDelegate,
                                    UIAdaptivePresentationControllerDelegate {
@@ -39,6 +39,7 @@ internal class ImagePickerHandler: NSObject,
     onMediaPickingResultHandler.didPickMedia(mediaInfo: mediaInfo)
   }
 
+  @available(iOS 14.0, *)
   private func handlePickedMedia(selection: [PHPickerResult]) {
     statusBarVisibilityController.maybeRestoreStatusBarVisibility()
     onMediaPickingResultHandler.didPickMultipleMedia(selection: selection)
@@ -63,15 +64,7 @@ internal class ImagePickerHandler: NSObject,
 
   // MARK: - PHPickerViewControllerDelegate
   
-  func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
-    // The PHPickerViewController returns empty collection when canceled
-    if results.isEmpty {
-      handlePickingCancellation()
-    } else {
-      handlePickedMedia(selection: results)
-    }
-    picker.dismiss(animated: true)
-  }
+  // Note: PHPickerViewControllerDelegate conformance is handled via extension below
 
   // MARK: - UIAdaptivePresentationControllerDelegate
 
@@ -100,6 +93,20 @@ extension UIImagePickerController: PickerUIController {
   }
 }
 
+@available(iOS 14.0, *)
+extension ImagePickerHandler: PHPickerViewControllerDelegate {
+  func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
+    // The PHPickerViewController returns empty collection when canceled
+    if results.isEmpty {
+      handlePickingCancellation()
+    } else {
+      handlePickedMedia(selection: results)
+    }
+    picker.dismiss(animated: true)
+  }
+}
+
+@available(iOS 14.0, *)
 extension PHPickerViewController: PickerUIController {
   func setResultHandler(_ handler: ImagePickerHandler) {
     self.delegate = handler
diff --git a/node_modules/expo-image-picker/ios/ImagePickerModule.swift b/node_modules/expo-image-picker/ios/ImagePickerModule.swift
index 4b7bf34..c7b31ca 100644
--- a/node_modules/expo-image-picker/ios/ImagePickerModule.swift
+++ b/node_modules/expo-image-picker/ios/ImagePickerModule.swift
@@ -92,7 +92,12 @@ public class ImagePickerModule: Module, OnMediaPickingResultHandler {
                                         imagePickerHandler: imagePickerDelegate)
 
     if !options.allowsEditing && sourceType != .camera {
-      self.launchMultiSelectPicker(pickingContext: pickingContext)
+      if #available(iOS 14.0, *) {
+        self.launchMultiSelectPicker(pickingContext: pickingContext)
+      } else {
+        // Fallback to legacy picker for iOS < 14.0
+        self.launchLegacyImagePicker(sourceType: sourceType, pickingContext: pickingContext)
+      }
     } else {
       self.launchLegacyImagePicker(sourceType: sourceType, pickingContext: pickingContext)
     }
@@ -152,18 +157,26 @@ public class ImagePickerModule: Module, OnMediaPickingResultHandler {
   }
 
   private func launchMultiSelectPicker(pickingContext: PickingContext) {
-    var configuration = PHPickerConfiguration(photoLibrary: PHPhotoLibrary.shared())
-    let options = pickingContext.options
-
-    // selection limit = 1 --> single selection, reflects the old picker behavior
-    configuration.selectionLimit = options.allowsMultipleSelection ? options.selectionLimit : SINGLE_SELECTION
-    configuration.filter = options.toPickerFilter()
-    configuration.preferredAssetRepresentationMode = options.preferredAssetRepresentationMode.toAssetRepresentationMode()
-    configuration.selection = options.orderedSelection ? .ordered : .default
+    if #available(iOS 14.0, *) {
+      var configuration = PHPickerConfiguration(photoLibrary: PHPhotoLibrary.shared())
+      let options = pickingContext.options
+
+      // selection limit = 1 --> single selection, reflects the old picker behavior
+      configuration.selectionLimit = options.allowsMultipleSelection ? options.selectionLimit : SINGLE_SELECTION
+      configuration.filter = options.toPickerFilter()
+      configuration.preferredAssetRepresentationMode = options.preferredAssetRepresentationMode.toAssetRepresentationMode()
+      // configuration.selection is only available in iOS 15.0+
+      if #available(iOS 15.0, *) {
+        configuration.selection = options.orderedSelection ? .ordered : .default
+      }
 
-    let picker = PHPickerViewController(configuration: configuration)
+      let picker = PHPickerViewController(configuration: configuration)
 
-    presentPickerUI(picker, pickingContext: pickingContext)
+      presentPickerUI(picker, pickingContext: pickingContext)
+    } else {
+      // Fallback to legacy picker for iOS < 14.0
+      launchLegacyImagePicker(sourceType: .photoLibrary, pickingContext: pickingContext)
+    }
   }
 
   private func presentPickerUI(_ picker: PickerUIController, pickingContext context: PickingContext) {
@@ -198,6 +211,7 @@ public class ImagePickerModule: Module, OnMediaPickingResultHandler {
     self.currentPickingContext = nil
   }
 
+  @available(iOS 14.0, *)
   func didPickMultipleMedia(selection: [PHPickerResult]) {
     guard let options = self.currentPickingContext?.options,
           let promise = self.currentPickingContext?.promise else {
@@ -237,15 +251,22 @@ public class ImagePickerModule: Module, OnMediaPickingResultHandler {
     // Clean up the currently stored picking context
     self.currentPickingContext = nil
 
-    let mediaHandler = MediaHandler(fileSystem: fileSystem,
-                                    options: options)
-    Task {
-      do {
-        let asset = try await mediaHandler.handleMedia(mediaInfo)
-        promise.resolve(ImagePickerResponse(assets: [asset], canceled: false))
-      } catch {
-        promise.reject(error)
+    if #available(iOS 14.0, *) {
+      let mediaHandler = MediaHandler(fileSystem: fileSystem,
+                                      options: options)
+      Task {
+        do {
+          let asset = try await mediaHandler.handleMedia(mediaInfo)
+          promise.resolve(ImagePickerResponse(assets: [asset], canceled: false))
+        } catch {
+          promise.reject(error)
+        }
       }
+    } else {
+      // Fallback for iOS < 14.0: use legacy UIImagePickerController handling
+      // This should not happen in practice as didPickMedia is called from UIImagePickerController
+      // which works on iOS < 14.0, but MediaHandler requires iOS 14.0+
+      promise.reject(Exception(name: "UnsupportediOSVersion", description: "MediaHandler requires iOS 14.0 or newer"))
     }
   }
 }
diff --git a/node_modules/expo-image-picker/ios/ImagePickerOptions.swift b/node_modules/expo-image-picker/ios/ImagePickerOptions.swift
index 38bfea9..765733c 100644
--- a/node_modules/expo-image-picker/ios/ImagePickerOptions.swift
+++ b/node_modules/expo-image-picker/ios/ImagePickerOptions.swift
@@ -56,21 +56,41 @@ internal struct ImagePickerOptions: Record {
   var orderedSelection: Bool = false
 
   func toMediaTypesArray() -> [String] {
-    var mediaTypesArray = mediaTypes.map { mediaType in
-      mediaType.toUTTypeString()
-    }
+    if #available(iOS 14.0, *) {
+      var mediaTypesArray = mediaTypes.map { mediaType in
+        mediaType.toUTTypeString()
+      }
 
-    // For legacy picker selecting only livePhotos is not allowed
-    if mediaTypes.contains(.livePhotos) && !mediaTypes.contains(.images) {
-      mediaTypesArray.append(UTType.image.identifier)
-    }
+      // For legacy picker selecting only livePhotos is not allowed
+      if mediaTypes.contains(.livePhotos) && !mediaTypes.contains(.images) {
+        mediaTypesArray.append(UTType.image.identifier)
+      }
 
-    if mediaTypesArray.isEmpty {
-      return [UTType.image.identifier]
+      if mediaTypesArray.isEmpty {
+        return [UTType.image.identifier]
+      }
+      return mediaTypesArray
+    } else {
+      // Fallback for iOS < 14.0: use legacy kUTType constants
+      var mediaTypesArray: [String] = []
+      for mediaType in mediaTypes {
+        switch mediaType {
+        case .images:
+          mediaTypesArray.append(kUTTypeImage as String)
+        case .videos:
+          mediaTypesArray.append(kUTTypeMovie as String)
+        case .livePhotos:
+          mediaTypesArray.append(kUTTypeImage as String) // Fallback to image
+        }
+      }
+      if mediaTypesArray.isEmpty {
+        return [kUTTypeImage as String]
+      }
+      return mediaTypesArray
     }
-    return mediaTypesArray
   }
 
+  @available(iOS 14.0, *)
   func toPickerFilter() -> PHPickerFilter {
     let allowedArray = mediaTypes.map { mediaType in
       mediaType.toPickerFilter()
@@ -132,6 +152,7 @@ internal enum PreferredAssetRepresentationMode: String, Enumerable {
   case compatible
   case current
 
+  @available(iOS 14.0, *)
   func toAssetRepresentationMode() -> PHPickerConfiguration.AssetRepresentationMode {
     switch self {
     case .automatic:
@@ -176,13 +197,25 @@ internal enum MediaType: String, Enumerable {
   case livePhotos
 
   func toUTTypeString() -> String {
-    switch self {
-    case .images:
-      return UTType.image.identifier
-    case .videos:
-      return UTType.movie.identifier
-    case .livePhotos:
-      return UTType.livePhoto.identifier
+    if #available(iOS 14.0, *) {
+      switch self {
+      case .images:
+        return UTType.image.identifier
+      case .videos:
+        return UTType.movie.identifier
+      case .livePhotos:
+        return UTType.livePhoto.identifier
+      }
+    } else {
+      // Fallback for iOS < 14.0: use legacy kUTType constants
+      switch self {
+      case .images:
+        return kUTTypeImage as String
+      case .videos:
+        return kUTTypeMovie as String
+      case .livePhotos:
+        return kUTTypeImage as String // Fallback to image
+      }
     }
   }
 
@@ -197,6 +230,7 @@ internal enum MediaType: String, Enumerable {
     }
   }
 
+  @available(iOS 14.0, *)
   func toPickerFilter() -> PHPickerFilter {
     switch self {
     case .images:
diff --git a/node_modules/expo-image-picker/ios/ImagePickerPermissionRequesters.swift b/node_modules/expo-image-picker/ios/ImagePickerPermissionRequesters.swift
index ffca254..99777e3 100644
--- a/node_modules/expo-image-picker/ios/ImagePickerPermissionRequesters.swift
+++ b/node_modules/expo-image-picker/ios/ImagePickerPermissionRequesters.swift
@@ -59,6 +59,7 @@ public class MediaLibraryWriteOnlyPermissionRequester: DefaultMediaLibraryPermis
     return "mediaLibraryWriteOnly"
   }
 
+  @available(iOS 14.0, *)
   override internal func accessLevel() -> PHAccessLevel {
     return PHAccessLevel.addOnly
   }
@@ -82,14 +83,26 @@ public class DefaultMediaLibraryPermissionRequester: NSObject {}
 extension DefaultMediaLibraryPermissionRequester {
   @objc
   public func requestPermissions(resolver resolve: @escaping EXPromiseResolveBlock, rejecter reject: EXPromiseRejectBlock) {
-    PHPhotoLibrary.requestAuthorization(for: self.accessLevel()) { [weak self] (_: PHAuthorizationStatus) in
-      resolve(self?.getPermissions())
+    if #available(iOS 14.0, tvOS 14.0, *) {
+      PHPhotoLibrary.requestAuthorization(for: self.accessLevel()) { [weak self] (_: PHAuthorizationStatus) in
+        resolve(self?.getPermissions())
+      }
+    } else {
+      PHPhotoLibrary.requestAuthorization { [weak self] (_: PHAuthorizationStatus) in
+        resolve(self?.getPermissions())
+      }
     }
   }
 
   @objc
   public func getPermissions() -> [AnyHashable: Any] {
-    let authorizationStatus = PHPhotoLibrary.authorizationStatus(for: self.accessLevel())
+    let authorizationStatus: PHAuthorizationStatus
+    if #available(iOS 14.0, tvOS 14.0, *) {
+      authorizationStatus = PHPhotoLibrary.authorizationStatus(for: self.accessLevel())
+    } else {
+      authorizationStatus = PHPhotoLibrary.authorizationStatus()
+    }
+    
     var status: EXPermissionStatus
     var scope: String
 
@@ -98,8 +111,14 @@ extension DefaultMediaLibraryPermissionRequester {
       status = EXPermissionStatusGranted
       scope = "all"
     case .limited:
-      status = EXPermissionStatusGranted
-      scope = "limited"
+      if #available(iOS 14.0, tvOS 14.0, *) {
+        status = EXPermissionStatusGranted
+        scope = "limited"
+      } else {
+        // Fallback for iOS < 14.0 (limited doesn't exist)
+        status = EXPermissionStatusGranted
+        scope = "all"
+      }
     case .denied, .restricted:
       status = EXPermissionStatusDenied
       scope = "none"
@@ -117,6 +136,7 @@ extension DefaultMediaLibraryPermissionRequester {
   }
 
   @objc
+  @available(iOS 14.0, *)
   internal func accessLevel() -> PHAccessLevel {
     return PHAccessLevel.readWrite
   }
diff --git a/node_modules/expo-image-picker/ios/ImageUtils.swift b/node_modules/expo-image-picker/ios/ImageUtils.swift
index d9d1cd4..3faaa5a 100644
--- a/node_modules/expo-image-picker/ios/ImageUtils.swift
+++ b/node_modules/expo-image-picker/ios/ImageUtils.swift
@@ -6,12 +6,14 @@ import ImageIO
 import Photos
 import UniformTypeIdentifiers
 
+@available(iOS 14.0, *)
 extension UTType {
   static var avif: UTType {
     UTType(importedAs: "public.avif")
   }
 }
 
+@available(iOS 14.0, *)
 internal struct ImageUtils {
   static func readImageFrom(mediaInfo: MediaInfo, shouldReadCroppedImage: Bool) -> UIImage? {
     // ---------------------------------------------------------------------------
diff --git a/node_modules/expo-image-picker/ios/MediaHandler.swift b/node_modules/expo-image-picker/ios/MediaHandler.swift
index 6e4fbe1..9f78287 100644
--- a/node_modules/expo-image-picker/ios/MediaHandler.swift
+++ b/node_modules/expo-image-picker/ios/MediaHandler.swift
@@ -6,6 +6,7 @@ import Photos
 import PhotosUI
 import UniformTypeIdentifiers
 
+@available(iOS 14.0, *)
 internal struct MediaHandler {
   internal weak var fileSystem: EXFileSystemInterface?
   internal let options: ImagePickerOptions
@@ -292,7 +293,15 @@ internal struct MediaHandler {
   }
 
   private func getMimeType(from pathExtension: String) -> String? {
-    return UTType(filenameExtension: pathExtension)?.preferredMIMEType
+    if #available(iOS 14.0, *) {
+      return UTType(filenameExtension: pathExtension)?.preferredMIMEType
+    } else {
+      // Fallback for iOS < 14.0: use legacy UTTypeCreatePreferredIdentifierForTag
+      guard let uti = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension as CFString, nil)?.takeRetainedValue() else {
+        return nil
+      }
+      return UTTypeCopyPreferredTagWithClass(uti, kUTTagClassMIMEType)?.takeRetainedValue() as String?
+    }
   }
 
   // MARK: - Video
diff --git a/node_modules/expo-image-picker/ios/NSItemProvider+Async.swift b/node_modules/expo-image-picker/ios/NSItemProvider+Async.swift
index 08cdf4c..28fa1f8 100644
--- a/node_modules/expo-image-picker/ios/NSItemProvider+Async.swift
+++ b/node_modules/expo-image-picker/ios/NSItemProvider+Async.swift
@@ -1,6 +1,7 @@
 import Foundation
 import Photos
 
+@available(iOS 14.0, *)
 internal extension NSItemProvider {
   func loadObject(ofClass objectClass: any NSItemProviderReading.Type) async throws -> NSItemProviderReading? {
     return try await withCheckedThrowingContinuation { continuation in
diff --git a/node_modules/expo-image-picker/ios/VideoUtils.swift b/node_modules/expo-image-picker/ios/VideoUtils.swift
index f78c50d..2a3d49e 100644
--- a/node_modules/expo-image-picker/ios/VideoUtils.swift
+++ b/node_modules/expo-image-picker/ios/VideoUtils.swift
@@ -5,6 +5,7 @@ import UniformTypeIdentifiers
 import Photos
 import ExpoModulesCore
 
+@available(iOS 14.0, *)
 internal struct VideoUtils {
   static func tryCopyingVideo(at: URL, to: URL) throws {
     do {
