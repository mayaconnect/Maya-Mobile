name: Setup Match (One-Time iOS Certificates) - API Key Only

# ---------------------------------------------------------------------------
#  ‚ö†Ô∏è  Ce workflow s'ex√©cute UNE SEULE FOIS pour initialiser fastlane match
#      - Utilise UNIQUEMENT une App Store Connect API Key (pas d'Apple ID / 2FA)
#      - Cr√©e les certificats iOS + provisioning profiles
#      - Stocke tout dans votre repo Git (MATCH_GIT_URL)
# ---------------------------------------------------------------------------

on:
  workflow_dispatch:
  

jobs:
  setup-match:
    name: üîê Initialize Match & Create iOS Certificates (API Key)
    runs-on: macos-15 # macOS 15 has Xcode 16.x

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      # ------------------------------
      #  Node & d√©pendances JS
      # ------------------------------
      - name: üì¶ Install dependencies
        shell: bash
        run: |
          set -euo pipefail
          npm ci

      - name: üóëÔ∏è Remove expo-dev-client (not needed for production builds)
        shell: bash
        run: |
          set -euo pipefail
          npm uninstall expo-dev-client

      # ------------------------------
      #  iOS native project (Expo)
      # ------------------------------
      - name: üîß Select Xcode 16.1
        shell: bash
        run: |
          set -euo pipefail
          sudo xcode-select -s /Applications/Xcode_16.1.app/Contents/Developer

      - name: üî® Generate iOS native folder
        shell: bash
        run: |
          set -euo pipefail
          npx expo prebuild --platform ios --clean

      - name: üîß Fix iOS nullability issues
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/fix-ios-nullability.sh
          bash scripts/fix-ios-nullability.sh

      # ------------------------------
      #  Ruby & fastlane
      # ------------------------------
      - name: üíé Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true

      # ------------------------------
      #  App Store Connect API Key
      #  - D√©code la cl√© .p8 depuis le secret BASE64
      #  - G√©n√®re ios/fastlane/keys/api_key.json au format attendu par fastlane
      # ------------------------------
      - name: üîê Create App Store Connect API Key files (p8 + api_key.json)
        shell: bash
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_KEY_BASE64 }}
        run: |
          set -euo pipefail

          mkdir -p ios/fastlane/keys

          # 1) V√©rifier que le secret base64 n'est pas un chemin de fichier
          echo "üîç Decoding App Store Connect API Key..."
          
          # D√©tecter si le secret contient un chemin de fichier au lieu du contenu base64
          if echo "${APP_STORE_CONNECT_KEY_BASE64}" | grep -qE "^[A-Z]:\\|^/|^\./|AuthKey_|\.p8"; then
            echo "‚ùå ERROR: The secret APP_STORE_CONNECT_KEY_BASE64 contains a file path instead of base64 content!"
            echo ""
            echo "The secret should contain the BASE64-ENCODED content of the .p8 file, not the file path."
            echo ""
            echo "To fix this:"
            echo "1. Download the .p8 file from App Store Connect"
            echo "2. Encode it to base64 using PowerShell:"
            echo "   \$path = \"AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8\""
            echo "   [Convert]::ToBase64String([System.IO.File]::ReadAllBytes(\$path)) | Set-Clipboard"
            echo "3. Paste the base64 string (not the file path) into the GitHub secret"
            exit 1
          fi
          
          # Nettoyer et d√©coder le secret base64 (supprimer espaces et retours √† la ligne)
          CLEAN_BASE64=$(echo "${APP_STORE_CONNECT_KEY_BASE64}" | tr -d '[:space:]')
          
          # V√©rifier que le secret base64 n'est pas vide apr√®s nettoyage
          if [ -z "${CLEAN_BASE64}" ]; then
            echo "‚ùå ERROR: APP_STORE_CONNECT_KEY_BASE64 secret is empty or contains only whitespace!"
            exit 1
          fi
          
          # 2) √âcrire le fichier .p8 √† partir du secret base64 nettoy√©
          p8_path="ios/fastlane/keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8"
          
          # D√©coder en v√©rifiant les erreurs
          if ! echo "${CLEAN_BASE64}" | base64 -d > "${p8_path}" 2>/dev/null; then
            echo "‚ùå ERROR: Failed to decode base64 content!"
            echo "   The secret APP_STORE_CONNECT_KEY_BASE64 may contain invalid base64 data."
            echo "   Please verify that you copied the complete base64 string without any modifications."
            exit 1
          fi
          
          chmod 600 "${p8_path}"
          
          # 3) V√©rifier que le fichier .p8 est valide
          if [ ! -s "${p8_path}" ]; then
            echo "‚ùå ERROR: Decoded .p8 file is empty!"
            echo "   The base64 content may be incorrect or incomplete."
            exit 1
          fi
          
          # V√©rifier le format du fichier .p8
          FIRST_LINE=$(head -1 "${p8_path}")
          if ! echo "${FIRST_LINE}" | grep -q "BEGIN PRIVATE KEY"; then
            echo "‚ùå ERROR: .p8 file format is invalid (should start with '-----BEGIN PRIVATE KEY-----')"
            echo "First line: ${FIRST_LINE}"
            echo ""
            echo "This usually means:"
            echo "1. The secret contains a file path instead of base64 content"
            echo "2. The base64 encoding is incorrect"
            echo "3. The secret was modified after encoding"
            echo ""
            echo "Please verify that APP_STORE_CONNECT_KEY_BASE64 contains the base64-encoded content of the .p8 file."
            exit 1
          fi
          
          if ! tail -1 "${p8_path}" | grep -q "END PRIVATE KEY"; then
            echo "‚ùå ERROR: .p8 file format is invalid (should end with '-----END PRIVATE KEY-----')"
            exit 1
          fi
          
          echo "‚úÖ .p8 file decoded and validated successfully"

          # 4) Cr√©er api_key.json pour fastlane (key_id, issuer_id, key_filepath)
          # Utiliser key_filepath au lieu d'embarquer la cl√© (plus s√ªr et recommand√©)
          echo "üìù Creating api_key.json (using key_filepath)..."
          python3 <<PY
          import json
          import os
          from pathlib import Path

          key_id = os.environ['APP_STORE_CONNECT_KEY_ID']
          issuer_id = os.environ['APP_STORE_CONNECT_ISSUER_ID']
          p8_path = Path(f'ios/fastlane/keys/AuthKey_{key_id}.p8')
          
          # V√©rifier que le fichier .p8 existe
          if not p8_path.exists():
              raise ValueError(f"P8 file not found: {p8_path}")
          
          # Lire la cl√© priv√©e pour validation
          key_content = p8_path.read_text(encoding='utf-8').strip()
          
          # V√©rifier que la cl√© commence et se termine correctement
          if not key_content.startswith('-----BEGIN PRIVATE KEY-----'):
              raise ValueError("Invalid .p8 file: missing BEGIN PRIVATE KEY header")
          if not key_content.endswith('-----END PRIVATE KEY-----'):
              raise ValueError("Invalid .p8 file: missing END PRIVATE KEY footer")
          
          # Cr√©er le dictionnaire JSON avec "key" (inline)
          # Note: Token.from_json_file() dans certaines versions de fastlane/spaceship
          # n'accepte QUE le format avec "key" (inline), pas "key_filepath"
          # Le script de test utilise Token.create() avec filepath (plus moderne)
          api_key_data = {
              "key_id": key_id,
              "issuer_id": issuer_id,
              "key": key_content,  # Cl√© inline (requis pour from_json_file)
              "in_house": False  # False pour les comptes App Store standard (pas enterprise)
          }
          
          # √âcrire le fichier JSON
          api_key_path = Path('ios/fastlane/keys/api_key.json')
          with open(api_key_path, 'w', encoding='utf-8') as f:
              json.dump(api_key_data, f, indent=2, ensure_ascii=False)
          
          print("‚úÖ api_key.json created successfully (using key_filepath)")
          PY
          
          if [ $? -ne 0 ]; then
            echo "‚ùå ERROR: Failed to create api_key.json"
            exit 1
          fi

          echo "‚úÖ API Key files created"
          
          # V√©rifier que les fichiers sont cr√©√©s correctement
          if [ ! -f "${p8_path}" ]; then
            echo "‚ùå ERROR: .p8 file not created at ${p8_path}"
            exit 1
          fi
          
          if [ ! -f "ios/fastlane/keys/api_key.json" ]; then
            echo "‚ùå ERROR: api_key.json not created"
            exit 1
          fi
          
          # V√©rifier le format JSON
          if ! python3 -m json.tool ios/fastlane/keys/api_key.json > /dev/null 2>&1; then
            echo "‚ùå ERROR: api_key.json is not valid JSON"
            echo "Content (first 500 chars):"
            head -c 500 ios/fastlane/keys/api_key.json
            exit 1
          fi
          
          echo "‚úÖ Files validated successfully"

      # ------------------------------
      # Diagnostic syst√®me et versions
      # ------------------------------
      - name: üîç System Diagnostics
        working-directory: ios
        shell: bash
        run: |
          set -euo pipefail
          
          echo "üìã System Information:"
          echo "  Date (UTC): $(date -u)"
          echo "  Date (Local): $(date)"
          echo ""
          echo "üì¶ Fastlane Version:"
          bundle exec fastlane --version || echo "  ‚ö†Ô∏è  Could not get fastlane version"
          echo ""
          echo "üíé Ruby Version:"
          bundle exec ruby -v || echo "  ‚ö†Ô∏è  Could not get Ruby version"
          echo ""
          echo "üì¶ Fastlane/Spaceship versions from Gemfile.lock:"
          if [ -f "../Gemfile.lock" ]; then
            grep -E "^\s+(fastlane|spaceship)" ../Gemfile.lock | head -5 || echo "  ‚ö†Ô∏è  Could not find fastlane/spaceship in Gemfile.lock"
          else
            echo "  ‚ö†Ô∏è  Gemfile.lock not found"
          fi

      # ------------------------------
      # Validation des credentials App Store Connect
      # ------------------------------
      - name: üîç Validate App Store Connect API Key
        working-directory: ios
        shell: bash
        run: |
          set -euo pipefail
          
          echo "üîç Validating App Store Connect API Key..."
          
          # V√©rifier que le fichier api_key.json existe
          if [ ! -f "fastlane/keys/api_key.json" ]; then
            echo "‚ùå ERROR: api_key.json not found"
            exit 1
          fi
          
          # Afficher et valider les informations
          echo "üìã API Key Info:"
          python3 <<PY
          import json
          import sys
          from pathlib import Path
          
          api_key_path = Path('fastlane/keys/api_key.json')
          with open(api_key_path, 'r') as f:
              data = json.load(f)
          
          # V√©rifier que tous les champs requis sont pr√©sents
          # On accepte soit 'key' (ancien format) soit 'key_filepath' (nouveau format recommand√©)
          required_fields = ['key_id', 'issuer_id']
          missing_fields = [field for field in required_fields if not data.get(field)]
          
          has_key = 'key' in data and data.get('key')
          has_key_filepath = 'key_filepath' in data and data.get('key_filepath')
          
          if missing_fields:
              print(f"‚ùå ERROR: Missing required fields in api_key.json: {', '.join(missing_fields)}")
              sys.exit(1)
          
          if not has_key and not has_key_filepath:
              print("‚ùå ERROR: api_key.json must contain either 'key' or 'key_filepath'")
              sys.exit(1)
          
          # Afficher les informations
          print(f"  Key ID: {data.get('key_id')}")
          print(f"  Issuer ID: {data.get('issuer_id')}")
          print(f"  In House: {data.get('in_house', False)}")
          
          if has_key_filepath:
              key_filepath = data.get('key_filepath')
              print(f"  Key Filepath: {key_filepath}")
              # V√©rifier que le fichier existe
              key_file = Path(key_filepath)
              if not key_file.exists():
                  print(f"‚ùå ERROR: Key file not found: {key_filepath}")
                  sys.exit(1)
              # Lire et valider le fichier
              key_content = key_file.read_text(encoding='utf-8').strip()
              if not key_content.startswith('-----BEGIN PRIVATE KEY-----'):
                  print("‚ùå ERROR: Key file doesn't start with '-----BEGIN PRIVATE KEY-----'")
                  sys.exit(1)
              if not key_content.endswith('-----END PRIVATE KEY-----'):
                  print("‚ùå ERROR: Key file doesn't end with '-----END PRIVATE KEY-----'")
                  sys.exit(1)
              print(f"  Key file preview: {key_content[:50]}...")
          elif has_key:
              key_content = data.get('key', '')
              if not key_content.startswith('-----BEGIN PRIVATE KEY-----'):
                  print("‚ùå ERROR: Key content doesn't start with '-----BEGIN PRIVATE KEY-----'")
                  sys.exit(1)
              if not key_content.endswith('-----END PRIVATE KEY-----'):
                  print("‚ùå ERROR: Key content doesn't end with '-----END PRIVATE KEY-----'")
                  sys.exit(1)
              print(f"  Key preview: {key_content[:50]}...")
              print("  ‚ÑπÔ∏è  Using embedded 'key' field (required for Token.from_json_file compatibility)")
          
          print("‚úÖ All required fields present and valid")
          PY
          
          if [ $? -ne 0 ]; then
            echo "‚ùå ERROR: api_key.json validation failed"
            exit 1
          fi
          
          # Afficher la structure de api_key.json (masqu√©e pour s√©curit√©)
          echo ""
          echo "üìã api_key.json structure (values masked):"
          python3 <<PY
          import json
          from pathlib import Path
          
          api_key_path = Path('fastlane/keys/api_key.json')
          with open(api_key_path, 'r') as f:
              data = json.load(f)
          
          # Afficher la structure avec valeurs masqu√©es
          masked_data = {}
          for key, value in data.items():
              if key == 'key':
                  masked_data[key] = f"*** ({len(str(value))} chars)" if value else "MISSING"
              elif key == 'key_filepath':
                  masked_data[key] = value  # Le chemin n'est pas sensible
              elif key in ['key_id', 'issuer_id']:
                  masked_data[key] = "***" if value else "MISSING"
              else:
                  masked_data[key] = value
          
          print(json.dumps(masked_data, indent=2))
          PY
          
          # V√©rifier le format du fichier .p8 et la correspondance avec api_key.json
          echo "üîç Validating .p8 file format and consistency..."
          
          # R√©cup√©rer le Key ID depuis api_key.json
          key_id=$(python3 -c "import json; print(json.load(open('fastlane/keys/api_key.json'))['key_id'])")
          expected_p8_file="fastlane/keys/AuthKey_${key_id}.p8"
          
          echo "  Expected .p8 file: ${expected_p8_file}"
          echo "  Key ID from api_key.json: ${key_id}"
          
          if [ ! -f "${expected_p8_file}" ]; then
            echo "‚ùå ERROR: .p8 file not found: ${expected_p8_file}"
            echo "   The .p8 filename must match: AuthKey_${key_id}.p8"
            echo "   Please verify that APP_STORE_CONNECT_KEY_ID matches the Key ID in App Store Connect"
            exit 1
          fi
          
          p8_file="${expected_p8_file}"
          
          # V√©rifier que le fichier .p8 commence par la bonne ent√™te
          if ! head -1 "${p8_file}" | grep -q "BEGIN PRIVATE KEY"; then
            echo "‚ùå ERROR: .p8 file format is invalid (should start with '-----BEGIN PRIVATE KEY-----')"
            echo "First line: $(head -1 "${p8_file}")"
            exit 1
          fi
          
          # V√©rifier que le fichier .p8 se termine correctement
          if ! tail -1 "${p8_file}" | grep -q "END PRIVATE KEY"; then
            echo "‚ùå ERROR: .p8 file format is invalid (should end with '-----END PRIVATE KEY-----')"
            exit 1
          fi
          
          echo "‚úÖ .p8 file format is valid"
          
          # Tester l'authentification avec fastlane spaceship
          echo "üîê Testing authentication with App Store Connect API..."
          echo "   This will attempt to connect to App Store Connect..."
          
          # Afficher les informations de diagnostic
          echo "üìã Diagnostic Information:"
          python3 <<PY
          import json
          from pathlib import Path
          
          api_key_path = Path('fastlane/keys/api_key.json')
          with open(api_key_path, 'r') as f:
              data = json.load(f)
          
          print(f"  Key ID: {data.get('key_id')}")
          print(f"  Issuer ID: {data.get('issuer_id')}")
          print("")
          print("üîç Please verify in App Store Connect:")
          print(f"   1. Go to https://appstoreconnect.apple.com/access/api")
          print(f"   2. Find the key with Key ID: {data.get('key_id')}")
          print(f"   3. Verify:")
          print(f"      - Status is 'Active' (not 'Expired' or 'Revoked')")
          print(f"      - Expiration date has not passed")
          print(f"      - Role is 'App Manager' or 'Admin'")
          print(f"   4. Verify Issuer ID at top of page matches: {data.get('issuer_id')}")
          PY
          
          # Cr√©er un script Ruby temporaire pour tester l'authentification
          # Utiliser Token.create avec filepath directement (plus compatible)
          cat > /tmp/test_auth.rb <<-'RUBY_SCRIPT'
          require 'spaceship'
          require 'json'

          # Lire les informations depuis api_key.json
          api_key_path = 'fastlane/keys/api_key.json'
          api_key_data = JSON.parse(File.read(api_key_path))

          key_id = api_key_data['key_id']
          issuer_id = api_key_data['issuer_id']

          # Utiliser key_filepath si pr√©sent, sinon construire le chemin
          if api_key_data['key_filepath']
            key_path = api_key_data['key_filepath']
          elsif api_key_data['key']
            # Si on a la cl√© inline, on doit l'√©crire dans un fichier temporaire
            temp_key_file = '/tmp/temp_auth_key.p8'
            File.write(temp_key_file, api_key_data['key'])
            key_path = temp_key_file
          else
            # Construire le chemin par d√©faut
            key_path = "fastlane/keys/AuthKey_#{key_id}.p8"
          end

          begin
            # Cr√©er le token directement avec filepath (plus compatible)
            token = Spaceship::ConnectAPI::Token.create(
              key_id: key_id,
              issuer_id: issuer_id,
              filepath: key_path
            )

            # Tester l'authentification en r√©cup√©rant les apps
            Spaceship::ConnectAPI.token = token
            apps = Spaceship::ConnectAPI::App.all

            puts "‚úÖ Authentication successful!"
            puts "   Found #{apps.length} app(s) in App Store Connect"
            if apps.length > 0
              puts "   First app: #{apps.first.name} (#{apps.first.bundle_id})"
            end
          rescue Spaceship::UnauthorizedAccessError => e
            puts "‚ùå ERROR: Authentication failed - Unauthorized"
            puts "   Error: #{e.message}"
            puts ""
            puts "   This usually means:"
            puts "   1. ‚ùå API key is EXPIRED or REVOKED in App Store Connect"
            puts "   2. ‚ùå Key ID or Issuer ID is INCORRECT"
            puts "   3. ‚ùå The .p8 file doesn't match the Key ID"
            puts ""
            puts "   ACTION REQUIRED:"
            puts "   1. Go to App Store Connect ‚Üí Users and Access ‚Üí Keys ‚Üí App Store Connect API"
            puts "   2. Check if the API key is still active"
            puts "   3. If expired/revoked, create a NEW API key"
            puts "   4. Download the new .p8 file"
            puts "   5. Update all GitHub secrets with the new values"
            exit 1
          rescue => e
            puts "‚ùå ERROR: Authentication failed"
            puts "   Error: #{e.message}"
            puts "   Error class: #{e.class}"
            puts ""
            puts "   Possible causes:"
            puts "   1. API key is expired or revoked"
            puts "   2. .p8 file is corrupted or incorrectly encoded"
            puts "   3. Key ID or Issuer ID is incorrect"
            puts "   4. API key doesn't have required permissions"
            puts "   5. Key file not found at: #{key_path}"
            exit 1
          ensure
            # Nettoyer le fichier temporaire si cr√©√©
            if File.exist?('/tmp/temp_auth_key.p8')
              File.delete('/tmp/temp_auth_key.p8')
            end
          end
          RUBY_SCRIPT
          
          if bundle exec ruby /tmp/test_auth.rb; then
            echo "‚úÖ App Store Connect API authentication test passed"
          else
            echo ""
            echo "‚ùå CRITICAL: App Store Connect authentication failed"
            echo "   Please verify your API key in App Store Connect:"
            echo "   https://appstoreconnect.apple.com/access/api"
            exit 1
          fi
          
          rm -f /tmp/test_auth.rb

      # ------------------------------
      # Matchfile (configuration de fastlane match)
      # ------------------------------
      - name: üìù Create Matchfile (API Key only)
        shell: bash
        run: |
          set -euo pipefail

          echo "üìù Creating Matchfile..."
          cat > ios/fastlane/Matchfile <<-EOF
          git_url("${{ secrets.MATCH_GIT_URL }}")
          storage_mode("git")
          type("appstore")
          app_identifier(["com.mayaconnect.app"])
          api_key_path("fastlane/keys/api_key.json")
          EOF

          echo "‚úÖ Matchfile created"
          echo ""
          echo "üìã Matchfile content:"
          cat ios/fastlane/Matchfile
          echo ""
          
          # Verify Matchfile is readable
          if [ ! -f "ios/fastlane/Matchfile" ]; then
            echo "‚ùå ERROR: Matchfile was not created"
            exit 1
          fi
          
          # Verify app_identifier is present
          if ! grep -q "app_identifier" ios/fastlane/Matchfile; then
            echo "‚ùå ERROR: app_identifier not found in Matchfile"
            exit 1
          fi
          
          echo "‚úÖ Matchfile validation passed"

      # ------------------------------
      # Diagnostic de l'authentification Git
      # ------------------------------
      - name: üîç Test Git Authentication
        shell: bash
        env:
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
        run: |
          set -euo pipefail

          echo "üîç Testing Git authentication..."
          echo "Repository URL: ${MATCH_GIT_URL}"
          
          # V√©rifier que les secrets sont d√©finis
          if [ -z "${MATCH_GIT_URL}" ]; then
            echo "‚ùå ERROR: MATCH_GIT_URL is not set"
            exit 1
          fi
          
          if [ -z "${MATCH_GIT_BASIC_AUTHORIZATION}" ]; then
            echo "‚ùå ERROR: MATCH_GIT_BASIC_AUTHORIZATION is not set"
            exit 1
          fi
          
          # D√©coder et v√©rifier le format de l'authentification
          echo "üîê Decoding authentication (first 20 chars only for security)..."
          DECODED=$(echo "${MATCH_GIT_BASIC_AUTHORIZATION}" | base64 -d 2>/dev/null || echo "INVALID_BASE64")
          if [ "${DECODED}" = "INVALID_BASE64" ]; then
            echo "‚ùå ERROR: MATCH_GIT_BASIC_AUTHORIZATION is not valid base64"
            exit 1
          fi
          
          # V√©rifier le format username:token
          if [[ ! "${DECODED}" =~ ^[^:]+:.+$ ]]; then
            echo "‚ùå ERROR: Authentication format should be 'username:token', got: ${DECODED:0:20}..."
            exit 1
          fi
          
          USERNAME=$(echo "${DECODED}" | cut -d: -f1)
          echo "‚úÖ Username detected: ${USERNAME}"
          echo "‚úÖ Authentication format is correct"
          
          # Tester l'acc√®s au repository
          echo "üîç Testing repository access..."
          TEMP_DIR=$(mktemp -d)
          trap "rm -rf ${TEMP_DIR}" EXIT
          
          if git clone \
            -c http.extraheader="Authorization: Basic ${MATCH_GIT_BASIC_AUTHORIZATION}" \
            "${MATCH_GIT_URL}" \
            "${TEMP_DIR}/test-clone" \
            2>&1; then
            echo "‚úÖ Repository access successful!"
            rm -rf "${TEMP_DIR}"
          else
            echo "‚ùå ERROR: Cannot access repository"
            echo "Please check:"
            echo "  1. Repository exists and is private"
            echo "  2. PAT token has 'repo' scope"
            echo "  3. PAT token has access to this repository"
            echo "  4. Username in base64 matches your GitHub username"
            exit 1
          fi

      # ------------------------------
      # Initialisation de match
      # ------------------------------
      - name: üé´ Initialize Match and Create Certificates (API Key)
        working-directory: ios
        shell: bash
        env:
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
        run: |
          set -euo pipefail

          echo "üîê Initializing Match with App Store Connect API Key..."
          bundle exec fastlane match appstore --verbose --force --skip_certificate_matching

          echo "‚úÖ Match initialized successfully!"
          echo "‚úÖ Certificates and profiles stored in: ${{ secrets.MATCH_GIT_URL }}"

      # ------------------------------
      # R√©sum√©
      # ------------------------------
      - name: ‚úÖ Success - Match is ready!
        shell: bash
        run: |
          set -euo pipefail

          echo "======================================"
          echo "üéâ MATCH SETUP COMPLETED!"
          echo "======================================"
          echo ""
          echo "‚úÖ iOS Certificates created"
          echo "‚úÖ Provisioning Profiles created"
          echo "‚úÖ Everything stored in: ${{ secrets.MATCH_GIT_URL }}"
          echo ""
          echo "üìã Next steps:"
          echo "1. The deploy workflow can now build iOS"
          echo "2. You can disable or delete this workflow"
          echo ""

