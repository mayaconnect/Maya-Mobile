name: Deploy to TestFlight & Google Play

on:
  # D√©ploiement automatique sur push vers master
  push:
    branches:
      - master
      - main

  # D√©ploiement manuel depuis l'interface GitHub
  workflow_dispatch:
    inputs:
      platform:
        description: 'Platform to deploy'
        required: true
        type: choice
        options:
          - both
          - android
          - ios
        default: 'both'

jobs:
  # ==========================================
  # JOB ANDROID - Build et Deploy sur Google Play
  # ==========================================
  deploy-android:
    name: ü§ñ Android ‚Üí Google Play
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.platform == 'android' || github.event.inputs.platform == 'both'))
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üì¶ Install dependencies (excluding dev dependencies for Release)
        run: npm ci --omit=dev

      - name: üíæ Backup Fastlane configuration
        run: |
          mkdir -p /tmp/fastlane-backup
          cp -r android/fastlane /tmp/fastlane-backup/ || echo "No fastlane folder to backup"

      - name: üî® Generate Android native folder
        run: npx expo prebuild --platform android --clean

      - name: üìã Restore Fastlane configuration
        run: |
          cp -r /tmp/fastlane-backup/fastlane android/
          echo "Fastlane configuration restored"
          ls -la android/fastlane/

      - name: üîß Set gradlew permissions
        working-directory: android
        run: |
          chmod +x gradlew
          echo "‚úÖ Gradlew permissions set"

      - name: üîß Generate React Native Codegen artifacts
        working-directory: android
        run: |
          echo "Generating codegen artifacts for all modules..."
          # Generate codegen artifacts for all native modules, not just the app
          ./gradlew generateCodegenArtifactsFromSchema --stacktrace || {
            echo "‚ö†Ô∏è Codegen generation had issues, but continuing..."
            exit 0
          }
          echo "‚úÖ Codegen artifacts generated"

      - name: üíé Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: üîê Decode Android keystore
        run: |
          echo "üì¶ Decoding keystore from GitHub secret..."
          mkdir -p android/app
          # Decode base64 keystore and save to android/app/
          # Support both old secret name (ANDROID_KEYSTORE_BASE64) and new (MAYA_UPLOAD_KEYSTORE_BASE64)
          KEYSTORE_BASE64=""
          KEYSTORE_SECRET=""
          
          # Check for MAYA_UPLOAD_KEYSTORE_BASE64 first (preferred)
          if [ -n "${{ secrets.MAYA_UPLOAD_KEYSTORE_BASE64 }}" ] && [ "${{ secrets.MAYA_UPLOAD_KEYSTORE_BASE64 }}" != "" ]; then
            KEYSTORE_BASE64="${{ secrets.MAYA_UPLOAD_KEYSTORE_BASE64 }}"
            KEYSTORE_SECRET="MAYA_UPLOAD_KEYSTORE_BASE64"
            echo "‚úÖ Found MAYA_UPLOAD_KEYSTORE_BASE64 secret"
          # Fallback to ANDROID_KEYSTORE_BASE64
          elif [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ] && [ "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" != "" ]; then
            KEYSTORE_BASE64="${{ secrets.ANDROID_KEYSTORE_BASE64 }}"
            KEYSTORE_SECRET="ANDROID_KEYSTORE_BASE64"
            echo "‚úÖ Found ANDROID_KEYSTORE_BASE64 secret (fallback)"
          else
            echo "‚ùå ERROR: No keystore secret found!"
            echo ""
            echo "Please set one of the following secrets in GitHub:"
            echo "  - MAYA_UPLOAD_KEYSTORE_BASE64 (preferred)"
            echo "  - ANDROID_KEYSTORE_BASE64 (fallback)"
            echo ""
            echo "To create the secret:"
            echo "  1. Encode your keystore file to Base64:"
            echo "     base64 -i your-keystore.jks | pbcopy  # macOS"
            echo "     base64 your-keystore.jks | clip      # Windows"
            echo "     base64 your-keystore.jks              # Linux"
            echo "  2. Go to GitHub Settings > Secrets and variables > Actions"
            echo "  3. Add a new secret named MAYA_UPLOAD_KEYSTORE_BASE64"
            echo "  4. Paste the Base64-encoded keystore content"
            exit 1
          fi
          
          # Decode and save keystore
          echo "Decoding keystore from $KEYSTORE_SECRET..."
          echo "$KEYSTORE_BASE64" | base64 --decode > android/app/maya-release.keystore
          
          # Verify the decoded file is valid
          if [ ! -s android/app/maya-release.keystore ]; then
            echo "‚ùå ERROR: Decoded keystore file is empty or invalid!"
            echo "Please check that the secret contains valid Base64-encoded keystore data"
            exit 1
          fi
          
          if [ ! -f "android/app/maya-release.keystore" ]; then
            echo "‚ùå ERROR: Failed to create keystore file"
            exit 1
          fi
          
          echo "‚úÖ Keystore decoded successfully at android/app/maya-release.keystore"
          ls -lh android/app/maya-release.keystore
          
          # Verify keystore SHA1 matches expected value
          echo "üîç Verifying keystore SHA1..."
          KEY_ALIAS="${{ secrets.MAYA_UPLOAD_KEY_ALIAS || secrets.ANDROID_KEY_ALIAS }}"
          STORE_PASSWORD="${{ secrets.MAYA_UPLOAD_STORE_PASSWORD || secrets.ANDROID_KEYSTORE_PASSWORD }}"
          EXPECTED_SHA1="${{ secrets.MAYA_UPLOAD_EXPECTED_SHA1 || secrets.ANDROID_KEYSTORE_EXPECTED_SHA1 }}"
          
          if [ -n "$EXPECTED_SHA1" ] && [ -n "$KEY_ALIAS" ] && [ -n "$STORE_PASSWORD" ]; then
            SHA1=$(keytool -list -v -keystore android/app/maya-release.keystore -alias "$KEY_ALIAS" -storepass "$STORE_PASSWORD" 2>/dev/null | grep "SHA1:" | awk '{print $2}' || echo "")
            echo "Keystore SHA1: $SHA1"
            if [ "$SHA1" = "$EXPECTED_SHA1" ]; then
              echo "‚úÖ Keystore SHA1 matches expected value!"
            else
              echo "‚ùå ERROR: Keystore SHA1 does NOT match expected value!"
              echo "Expected: $EXPECTED_SHA1"
              echo "Got:      $SHA1"
              echo ""
              echo "This will cause Google Play to reject the AAB."
              echo "Please update the keystore secret with the correct keystore."
              exit 1
            fi
          else
            echo "‚ÑπÔ∏è Skipping SHA1 verification (no expected SHA1 secret provided or missing alias/password)"
          fi

      - name: ‚öôÔ∏è Configure signing properties (Gradle)
        run: |
          echo "‚öôÔ∏è Configuring signing properties in gradle.properties..."
          # Ensure gradle.properties exists (expo prebuild may or may not create it)
          if [ ! -f "android/gradle.properties" ]; then
            echo "Creating android/gradle.properties..."
            touch android/gradle.properties
          fi
          
          # Remove any existing MAYA_UPLOAD properties to avoid duplicates
          if [ -f "android/gradle.properties" ]; then
            sed -i.bak '/^MAYA_UPLOAD/d' android/gradle.properties || sed -i '/^MAYA_UPLOAD/d' android/gradle.properties
          fi
          
          # Append signing properties to gradle.properties
          # Support both old and new secret names for backward compatibility
          # Note: MAYA_UPLOAD_STORE_FILE is relative to android/app/ directory (where build.gradle is)
          # The keystore is created at android/app/maya-release.keystore
          # Since build.gradle is in android/app/, the path should be just "maya-release.keystore"
          cat >> android/gradle.properties <<EOF
          # Android signing configuration (injected at CI runtime)
          MAYA_UPLOAD_STORE_FILE=maya-release.keystore
          MAYA_UPLOAD_STORE_PASSWORD=${{ secrets.MAYA_UPLOAD_STORE_PASSWORD || secrets.ANDROID_KEYSTORE_PASSWORD }}
          MAYA_UPLOAD_KEY_ALIAS=${{ secrets.MAYA_UPLOAD_KEY_ALIAS || secrets.ANDROID_KEY_ALIAS }}
          MAYA_UPLOAD_KEY_PASSWORD=${{ secrets.MAYA_UPLOAD_KEY_PASSWORD || secrets.ANDROID_KEY_PASSWORD }}
          EOF
          echo "‚úÖ Signing properties configured"
          # Show the properties (without passwords) for verification
          echo "Configured properties:"
          grep "MAYA_UPLOAD" android/gradle.properties | sed 's/PASSWORD=.*/PASSWORD=***/' || true
          
          # Also add other Gradle settings if they don't exist
          if ! grep -q "org.gradle.jvmargs" android/gradle.properties; then
            cat >> android/gradle.properties <<EOF
          
          # Gradle settings
          org.gradle.jvmargs=-Xmx2048m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
          org.gradle.parallel=true
          org.gradle.configureondemand=true
          android.useAndroidX=true
          android.enableJetifier=true
          
          # React Native / Hermes settings
          hermesEnabled=true
          newArchEnabled=true
          EOF
            echo "‚úÖ Additional Gradle settings added"
          fi
          
          # Note: Removed deprecated options:
          # - android.bundle.enableUncompressedNativeLibs (deprecated in AGP 8.x+)
          # - android.defaults.buildfeatures.buildconfig (deprecated in AGP 8.x+)
          # Debug symbols are already disabled via ndk { debugSymbolLevel 'NONE' } in build.gradle

      - name: üîß Generate React Native Codegen artifacts
        working-directory: android
        run: |
          echo "Generating codegen artifacts for all modules..."
          # Generate codegen artifacts for all native modules, not just the app
          ./gradlew generateCodegenArtifactsFromSchema --stacktrace || {
            echo "‚ö†Ô∏è Codegen generation had issues, but continuing..."
            exit 0
          }
          echo "‚úÖ Codegen artifacts generated"

      - name: üîë Create Google Play service account JSON
        run: |
          mkdir -p android/fastlane
          echo '${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}' > android/fastlane/google-play-service-account.json
          echo "Service account configured"

      - name: ‚òï Verify Java and jarsigner availability
        run: |
          echo "‚òï Checking Java installation..."
          java -version
          echo ""
          echo "üîç Checking jarsigner availability..."
          jarsigner -help > /dev/null 2>&1 && echo "‚úÖ jarsigner is available" || (echo "‚ùå jarsigner not found" && exit 1)
          keytool -help > /dev/null 2>&1 && echo "‚úÖ keytool is available" || (echo "‚ùå keytool not found" && exit 1)

      - name: ‚úÖ Verify release signing configuration before build
        working-directory: android
        run: |
          echo "‚úÖ Verifying release signing configuration..."
          
          # Check that release keystore properties are set
          if ! grep -q "MAYA_UPLOAD_STORE_FILE" gradle.properties; then
            echo "‚ùå ERROR: MAYA_UPLOAD_STORE_FILE not found in gradle.properties"
            echo "This would cause Gradle to use debug certificate - ABORTING!"
            exit 1
          fi
          
          # Verify keystore file exists
          KEYSTORE_FILE=$(grep "MAYA_UPLOAD_STORE_FILE" gradle.properties | cut -d'=' -f2 | tr -d ' ')
          if [ ! -f "app/$KEYSTORE_FILE" ]; then
            echo "‚ùå ERROR: Keystore file not found: app/$KEYSTORE_FILE"
            exit 1
          fi
          
          # Verify it's NOT the debug keystore
          if [ "$KEYSTORE_FILE" = "debug.keystore" ]; then
            echo "‚ùå ERROR: Debug keystore detected! This must not be used for release builds!"
            exit 1
          fi
          
          echo "‚úÖ Release signing configuration verified:"
          echo "   - Keystore file: $KEYSTORE_FILE"
          echo "   - Keystore exists: ‚úì"
          echo "   - Not debug keystore: ‚úì"

      - name: üî® Build Android App Bundle (AAB) - Signed with Release Certificate
        working-directory: android
        run: |
          echo "üî® Building AAB with Gradle (signed with release certificate ONLY)..."
          echo "‚ö†Ô∏è  If build fails with 'Release keystore not configured', check gradle.properties"
          
          # Build and sign with release keystore (configured in gradle.properties)
          # This ensures only the release certificate is used, no debug certificate
          # The build will FAIL if release keystore is not configured (see build.gradle)
          ./gradlew bundleRelease --stacktrace --info --no-daemon
          
          echo "‚úÖ AAB built and signed successfully with release certificate"
          ls -lh app/build/outputs/bundle/release/app-release.aab
          
          # Check if BUNDLE-METADATA exists (it should NOT if debugSymbolLevel 'NONE' worked)
          echo ""
          echo "üîç Checking if BUNDLE-METADATA exists in built AAB..."
          TEMP_CHECK_BUILD=$(mktemp -d)
          unzip -q app/build/outputs/bundle/release/app-release.aab -d "$TEMP_CHECK_BUILD" 2>/dev/null || true
          if [ -d "$TEMP_CHECK_BUILD/BUNDLE-METADATA/com.android.tools.build.debugsymbols" ]; then
            FILE_COUNT_BUILD=$(find "$TEMP_CHECK_BUILD/BUNDLE-METADATA/com.android.tools.build.debugsymbols" -type f 2>/dev/null | wc -l)
            echo "‚ö†Ô∏è  WARNING: BUNDLE-METADATA/com.android.tools.build.debugsymbols exists with $FILE_COUNT_BUILD files"
            echo "   debugSymbolLevel 'NONE' did not work - will be removed in next step"
          else
            echo "‚úÖ No BUNDLE-METADATA/com.android.tools.build.debugsymbols found (good)"
          fi
          rm -rf "$TEMP_CHECK_BUILD"

      - name: üßπ Remove BUNDLE-METADATA (1433 debug-signed files) BEFORE signing
        working-directory: android
        run: |
          echo "üßπ REMOVING BUNDLE-METADATA directory (contains 1433 files signed with debug certificate)..."
          echo "   This MUST be done BEFORE signing to prevent debug certificates"
          AAB_PATH="app/build/outputs/bundle/release/app-release.aab"
          
          if [ ! -f "$AAB_PATH" ]; then
            echo "‚ùå ERROR: AAB file not found at $AAB_PATH"
            exit 1
          fi
          
          # Verify zip/unzip are available
          if ! command -v zip &> /dev/null || ! command -v unzip &> /dev/null; then
            echo "Installing zip/unzip..."
            sudo apt-get update && sudo apt-get install -y zip unzip
          fi
          
          # METHOD 1: Try to delete BUNDLE-METADATA directly from AAB using zip -d (faster)
          echo "Attempting to delete BUNDLE-METADATA directly from AAB using zip -d..."
          zip -d "$AAB_PATH" "BUNDLE-METADATA/*" 2>&1 || true
          zip -d "$AAB_PATH" "*/BUNDLE-METADATA/*" 2>&1 || true
          
          # Verify it's gone
          TEMP_CHECK_DIRECT=$(mktemp -d)
          unzip -q "$AAB_PATH" -d "$TEMP_CHECK_DIRECT" 2>/dev/null || true
          if [ ! -d "$TEMP_CHECK_DIRECT/BUNDLE-METADATA" ]; then
            echo "‚úÖ BUNDLE-METADATA successfully removed using zip -d"
            rm -rf "$TEMP_CHECK_DIRECT"
            exit 0  # Success, no need to continue
          fi
          rm -rf "$TEMP_CHECK_DIRECT"
          echo "‚ö†Ô∏è  zip -d did not work, trying extraction method..."
          
          # METHOD 2: Extract, remove, recreate (fallback)
          # Create temporary directory
          TEMP_DIR=$(mktemp -d)
          echo "Extracting AAB..."
          
          # Extract AAB
          unzip -q "$AAB_PATH" -d "$TEMP_DIR" || {
            echo "‚ùå ERROR: Failed to extract AAB"
            exit 1
          }
          
          # CRITICAL: Remove ENTIRE BUNDLE-METADATA directory (contains 1433 .sym files signed with debug)
          if [ -d "$TEMP_DIR/BUNDLE-METADATA" ]; then
            echo "üî¥ REMOVING ENTIRE BUNDLE-METADATA directory (CRITICAL - contains 1433 debug-signed files)..."
            DEBUG_SYMBOLS_DIR="$TEMP_DIR/BUNDLE-METADATA/com.android.tools.build.debugsymbols"
            if [ -d "$DEBUG_SYMBOLS_DIR" ]; then
              FILE_COUNT=$(find "$DEBUG_SYMBOLS_DIR" -type f 2>/dev/null | wc -l)
              echo "   Found $FILE_COUNT files in debug symbols directory (these cause debug certificate references)"
              echo "   Directory size:"
              du -sh "$DEBUG_SYMBOLS_DIR" 2>/dev/null || true
            fi
            
            # Force remove with multiple methods
            echo "   Attempting removal..."
            rm -rf "$TEMP_DIR/BUNDLE-METADATA" 2>&1 || true
            sleep 1  # Give filesystem time to process
            
            # Verify it's gone with multiple checks
            if [ -d "$TEMP_DIR/BUNDLE-METADATA" ]; then
              echo "‚ùå FATAL ERROR: Failed to remove BUNDLE-METADATA directory!"
              echo "   Trying force removal with chmod..."
              chmod -R 777 "$TEMP_DIR/BUNDLE-METADATA" 2>/dev/null || true
              rm -rf "$TEMP_DIR/BUNDLE-METADATA" 2>&1 || true
              sleep 1
              
              if [ -d "$TEMP_DIR/BUNDLE-METADATA" ]; then
                echo "‚ùå FATAL: Cannot remove BUNDLE-METADATA even with force removal!"
                echo "   This will cause 1433 debug certificate references!"
                exit 1
              fi
            fi
            
            # Final verification
            if [ ! -d "$TEMP_DIR/BUNDLE-METADATA" ]; then
              echo "‚úÖ BUNDLE-METADATA directory completely removed ($FILE_COUNT files deleted)"
            else
              echo "‚ùå FATAL: BUNDLE-METADATA still exists after all removal attempts!"
              exit 1
            fi
          else
            echo "‚ÑπÔ∏è  No BUNDLE-METADATA directory found (good - debugSymbolLevel 'NONE' worked)"
          fi
          
          # Remove ALL META-INF directories
          echo "Removing ALL META-INF directories..."
          if [ -d "$TEMP_DIR/META-INF" ]; then
            rm -rf "$TEMP_DIR/META-INF"
          fi
          
          # Remove META-INF from all JARs
          find "$TEMP_DIR" -name "*.jar" -type f | while read -r jar_file; do
            JAR_TEMP=$(mktemp -d)
            if unzip -q "$jar_file" -d "$JAR_TEMP" 2>/dev/null; then
              find "$JAR_TEMP" -type d -name "META-INF" -exec rm -rf {} + 2>/dev/null || true
              (cd "$JAR_TEMP" && zip -q -r "$jar_file" . 2>/dev/null) || true
            fi
            rm -rf "$JAR_TEMP"
          done
          
          # FINAL VERIFICATION: BUNDLE-METADATA must not exist
          if [ -d "$TEMP_DIR/BUNDLE-METADATA" ]; then
            echo "‚ùå FATAL: BUNDLE-METADATA still exists after removal!"
            exit 1
          fi
          
          # Recreate AAB WITHOUT BUNDLE-METADATA (use -x to explicitly exclude it)
          echo "Recreating AAB WITHOUT BUNDLE-METADATA (using explicit exclusion)..."
          cd "$TEMP_DIR"
          # Use -x to explicitly exclude BUNDLE-METADATA even if it somehow still exists
          # Also exclude any .sym files that might be elsewhere
          rm -f "$OLDPWD/$AAB_PATH" || true  # Delete old AAB first
          zip -q -r "$OLDPWD/$AAB_PATH" . -x "BUNDLE-METADATA/*" "*/BUNDLE-METADATA/*" "*.sym" "*/debugsymbols/*" || {
            echo "‚ùå ERROR: Failed to recreate AAB"
            exit 1
          }
          cd "$OLDPWD"
          
          # CRITICAL VERIFICATION: BUNDLE-METADATA must not be in the recreated AAB
          echo "üîç CRITICAL: Verifying BUNDLE-METADATA is NOT in recreated AAB..."
          TEMP_VERIFY=$(mktemp -d)
          unzip -q "$AAB_PATH" -d "$TEMP_VERIFY" 2>/dev/null || true
          if [ -d "$TEMP_VERIFY/BUNDLE-METADATA" ]; then
            echo "‚ùå FATAL ERROR: BUNDLE-METADATA still in AAB after recreation!"
            if [ -d "$TEMP_VERIFY/BUNDLE-METADATA/com.android.tools.build.debugsymbols" ]; then
              FILE_COUNT_VERIFY=$(find "$TEMP_VERIFY/BUNDLE-METADATA/com.android.tools.build.debugsymbols" -type f 2>/dev/null | wc -l)
              echo "   Found $FILE_COUNT_VERIFY files in debug symbols directory!"
              echo "   This will cause $FILE_COUNT_VERIFY debug certificate references!"
            fi
            echo "   Listing BUNDLE-METADATA contents:"
            ls -la "$TEMP_VERIFY/BUNDLE-METADATA/" 2>/dev/null || true
            rm -rf "$TEMP_VERIFY"
            exit 1
          fi
          rm -rf "$TEMP_VERIFY"
          echo "‚úÖ VERIFIED: BUNDLE-METADATA is NOT in the AAB (1433 debug files eliminated)"
          
          # Cleanup
          rm -rf "$TEMP_DIR"
          
          echo "‚úÖ AAB cleaned: BUNDLE-METADATA removed, ready for signing"

      - name: ‚úçÔ∏è Remove debug signatures and re-sign AAB (preserve structure)
        working-directory: android
        run: |
          echo "‚úçÔ∏è Removing debug signatures and re-signing AAB..."
          echo "   IMPORTANT: Preserving AAB structure to avoid signature corruption"
          AAB_PATH="app/build/outputs/bundle/release/app-release.aab"
          KEYSTORE_PATH="app/maya-release.keystore"
          KEY_ALIAS="${{ secrets.MAYA_UPLOAD_KEY_ALIAS || secrets.ANDROID_KEY_ALIAS }}"
          STORE_PASSWORD="${{ secrets.MAYA_UPLOAD_STORE_PASSWORD || secrets.ANDROID_KEYSTORE_PASSWORD }}"
          KEY_PASSWORD="${{ secrets.MAYA_UPLOAD_KEY_PASSWORD || secrets.ANDROID_KEY_PASSWORD }}"
          
          if [ ! -f "$AAB_PATH" ]; then
            echo "‚ùå ERROR: AAB file not found at $AAB_PATH"
            exit 1
          fi
          
          if [ ! -f "$KEYSTORE_PATH" ]; then
            echo "‚ùå ERROR: Keystore file not found at $KEYSTORE_PATH"
            exit 1
          fi
          
          # VERIFY BUNDLE-METADATA is NOT in AAB (should have been removed in previous step)
          echo "üîç Verifying BUNDLE-METADATA is NOT in AAB..."
          TEMP_CHECK=$(mktemp -d)
          unzip -q "$AAB_PATH" -d "$TEMP_CHECK" 2>/dev/null || true
          if [ -d "$TEMP_CHECK/BUNDLE-METADATA" ]; then
            echo "‚ùå FATAL ERROR: BUNDLE-METADATA still exists in AAB!"
            echo "   This means the previous cleanup step failed!"
            rm -rf "$TEMP_CHECK"
            exit 1
          fi
          rm -rf "$TEMP_CHECK"
          echo "‚úÖ Verified: BUNDLE-METADATA is NOT in AAB (good)"
          
          # Remove only ANDROIDD.* debug signature files (keep META-INF structure)
          echo "Removing ANDROIDD.* debug signature files from META-INF..."
          zip -d "$AAB_PATH" "META-INF/ANDROIDD.SF" 2>/dev/null || true
          zip -d "$AAB_PATH" "META-INF/ANDROIDD.RSA" 2>/dev/null || true
          zip -d "$AAB_PATH" "META-INF/ANDROIDD.DSA" 2>/dev/null || true
          zip -d "$AAB_PATH" "META-INF/ANDROIDD.EC" 2>/dev/null || true
          zip -d "$AAB_PATH" "META-INF/ANDROIDD*" 2>/dev/null || true
          
          # Verify ANDROIDD files are gone
          TEMP_CHECK2=$(mktemp -d)
          unzip -q "$AAB_PATH" -d "$TEMP_CHECK2" 2>/dev/null || true
          ANDROIDD_FILES=$(find "$TEMP_CHECK2/META-INF" -name "ANDROIDD*" 2>/dev/null | wc -l)
          if [ "$ANDROIDD_FILES" -gt 0 ]; then
            echo "‚ö†Ô∏è  WARNING: Some ANDROIDD files still exist, removing them..."
            find "$TEMP_CHECK2/META-INF" -name "ANDROIDD*" -delete 2>/dev/null || true
            # Recreate AAB if we had to delete files manually
            cd "$TEMP_CHECK2"
            rm -f "$OLDPWD/$AAB_PATH"
            zip -q -r "$OLDPWD/$AAB_PATH" . || {
              echo "‚ùå ERROR: Failed to recreate AAB"
              exit 1
            }
            cd "$OLDPWD"
          fi
          rm -rf "$TEMP_CHECK2"
          
          echo "‚úÖ Debug signatures removed, AAB structure preserved"
          
          # Re-sign the AAB with release certificate
          # Use -signedjar to create a new signed AAB (preserves structure better)
          echo "üì¶ Re-signing $AAB_PATH with release keystore (alias: $KEY_ALIAS)..."
          echo "   Algorithm: SHA256withRSA"
          
          # Create temporary signed AAB
          AAB_SIGNED="${AAB_PATH}.signed"
          
          jarsigner \
            -keystore "$KEYSTORE_PATH" \
            -storepass "$STORE_PASSWORD" \
            -keypass "$KEY_PASSWORD" \
            -sigalg SHA256withRSA \
            -digestalg SHA-256 \
            "$AAB_PATH" \
            "$KEY_ALIAS"
          
          # Verify the signature is valid
          echo ""
          echo "üîç Verifying AAB signature after re-signing..."
          if jarsigner -verify "$AAB_PATH" > /dev/null 2>&1; then
            echo "‚úÖ AAB signature is VALID after re-signing"
            echo "‚úÖ AAB re-signed successfully with release certificate"
            echo "‚úÖ BUNDLE-METADATA removed (no debug certificates)"
            echo "‚úÖ Debug signatures (ANDROIDD.*) removed"
          else
            echo "‚ùå ERROR: AAB signature verification failed after re-signing!"
            echo "   This may indicate:"
            echo "   1. The keystore or certificate is incorrect"
            echo "   2. The certificate does not match the one registered in Google Play Console"
            echo "   3. The AAB structure was corrupted during processing"
            echo ""
            echo "   Please verify:"
            echo "   - The keystore secret (MAYA_UPLOAD_KEYSTORE_BASE64) contains the correct keystore"
            echo "   - The key alias and passwords match the keystore"
            echo "   - The certificate SHA1 matches the one in Google Play Console"
            exit 1
          fi

      - name: üîç Verify AAB signature (release certificate only, no debug)
        working-directory: android
        run: |
          echo "üîç Verifying AAB signature and checking for release certificate only..."
          echo "   Also verifying certificate matches Google Play requirements..."
          AAB_PATH="app/build/outputs/bundle/release/app-release.aab"
          
          # Get certificate info for verification
          KEY_ALIAS="${{ secrets.MAYA_UPLOAD_KEY_ALIAS || secrets.ANDROID_KEY_ALIAS }}"
          STORE_PASSWORD="${{ secrets.MAYA_UPLOAD_STORE_PASSWORD || secrets.ANDROID_KEYSTORE_PASSWORD }}"
          EXPECTED_SHA1="${{ secrets.MAYA_UPLOAD_EXPECTED_SHA1 || secrets.ANDROID_KEYSTORE_EXPECTED_SHA1 }}"
          
          # Verify signature
          echo "Running jarsigner verification..."
          jarsigner -verify -verbose -certs "$AAB_PATH" > /tmp/jarsigner_output.txt 2>&1
          VERIFY_EXIT_CODE=$?
          
          # Count all signers
          echo ""
          echo "Analyzing all certificates in AAB..."
          SIGNER_COUNT=$(grep -c ">>> Signer" /tmp/jarsigner_output.txt || echo "0")
          DEBUG_COUNT=$(grep -c "Android Debug" /tmp/jarsigner_output.txt || echo "0")
          RELEASE_COUNT=$(grep -c "Manuel Castilla\|Maya" /tmp/jarsigner_output.txt || echo "0")
          
          echo "   Total signers found: $SIGNER_COUNT"
          echo "   Release certificate (Manuel Castilla): $RELEASE_COUNT"
          echo "   Debug certificate (Android Debug): $DEBUG_COUNT"
          
          if [ $VERIFY_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è  WARNING: jarsigner verification returned non-zero exit code"
            echo "   (This may be due to self-signed certificate - checking for debug certificate...)"
          fi
          
          # Check for debug certificate (should not be present)
          echo ""
          echo "Checking for debug certificate..."
          if [ "$DEBUG_COUNT" -gt 0 ] || grep -q "Android Debug" /tmp/jarsigner_output.txt; then
            echo "‚ùå ERROR: Debug certificate detected in AAB!"
            echo "This will cause Google Play to reject the AAB."
            echo ""
            echo "Found $DEBUG_COUNT debug certificate reference(s):"
            grep -i "Android Debug" /tmp/jarsigner_output.txt | head -10
            echo ""
            
            # Check if BUNDLE-METADATA is still in the AAB (this is the source of the problem)
            echo "üîç Checking if BUNDLE-METADATA is still in AAB (source of debug certificates)..."
            TEMP_DEBUG_CHECK=$(mktemp -d)
            unzip -q "$AAB_PATH" -d "$TEMP_DEBUG_CHECK" 2>/dev/null || true
            if [ -d "$TEMP_DEBUG_CHECK/BUNDLE-METADATA/com.android.tools.build.debugsymbols" ]; then
              FILE_COUNT_DEBUG=$(find "$TEMP_DEBUG_CHECK/BUNDLE-METADATA/com.android.tools.build.debugsymbols" -type f 2>/dev/null | wc -l)
              echo "‚ùå ROOT CAUSE: BUNDLE-METADATA/com.android.tools.build.debugsymbols still exists!"
              echo "   Contains $FILE_COUNT_DEBUG files signed with debug certificate"
              echo "   This explains the $DEBUG_COUNT debug certificate references"
            fi
            rm -rf "$TEMP_DEBUG_CHECK"
            
            echo ""
            echo "Full verification output (first 100 lines):"
            head -100 /tmp/jarsigner_output.txt
            echo ""
            echo "‚ùå Build will fail - debug certificate must be completely removed"
            exit 1
          else
            echo "‚úÖ No debug certificate found - SUCCESS!"
            echo "‚úÖ Only release certificate (Manuel Castilla) is present"
          fi
          
          # Note about "Invalid certificate chain" warning
          if grep -q "Invalid certificate chain" /tmp/jarsigner_output.txt; then
            echo ""
            echo "‚ÑπÔ∏è  Note: 'Invalid certificate chain' warning is NORMAL for self-signed certificates"
            echo "   This is NOT a problem for Google Play - self-signed certificates are accepted"
            echo "   as long as the certificate matches the one registered in Google Play Console"
          fi
          
          # Check for release certificate (should be present)
          echo ""
          echo "Checking for release certificate..."
          if grep -q "Manuel Castilla\|Maya" /tmp/jarsigner_output.txt || [ -n "$KEY_ALIAS" ]; then
            echo "‚úÖ Release certificate found"
            
            # Verify SHA1 matches Google Play requirement
            if [ -n "$EXPECTED_SHA1" ]; then
              echo ""
              echo "üîê Verifying certificate SHA1 matches Google Play requirement..."
              # Extract SHA1 from AAB signature
              AAB_SHA1=$(grep -A 10 "Certificate chain" /tmp/jarsigner_output.txt | grep "SHA1:" | head -1 | awk '{print $2}' || echo "")
              
              if [ -n "$AAB_SHA1" ]; then
                echo "   AAB Certificate SHA1: $AAB_SHA1"
                echo "   Expected SHA1 (Google Play): $EXPECTED_SHA1"
                
                # Normalize SHA1 (remove colons and convert to uppercase for comparison)
                AAB_SHA1_NORM=$(echo "$AAB_SHA1" | tr -d ':' | tr '[:lower:]' '[:upper:]')
                EXPECTED_SHA1_NORM=$(echo "$EXPECTED_SHA1" | tr -d ':' | tr '[:lower:]' '[:upper:]')
                
                if [ "$AAB_SHA1_NORM" = "$EXPECTED_SHA1_NORM" ]; then
                  echo "   ‚úÖ Certificate SHA1 MATCHES Google Play requirement!"
                  echo "   ‚úÖ This AAB will be accepted by Google Play"
                else
                  echo "   ‚ö†Ô∏è  WARNING: Certificate SHA1 does NOT match expected value"
                  echo "   This may cause Google Play to reject the AAB"
                  echo "   Please verify the keystore matches the one registered in Google Play Console"
                fi
              else
                echo "   ‚ö†Ô∏è  Could not extract SHA1 from AAB signature"
              fi
            else
              echo "   ‚ÑπÔ∏è  Skipping SHA1 verification (EXPECTED_SHA1 not set in secrets)"
              echo "   üí° Tip: Set MAYA_UPLOAD_EXPECTED_SHA1 secret with the SHA1 from Google Play Console"
            fi
          else
            echo "‚ö†Ô∏è WARNING: Could not confirm release certificate presence"
          fi
          
          # Check for multiple certificate chains
          echo ""
          echo "Checking certificate chains..."
          CERT_COUNT=$(grep -c "Certificate chain" /tmp/jarsigner_output.txt || echo "0")
          
          if [ "$CERT_COUNT" -gt 1 ]; then
            echo "‚ùå ERROR: Multiple certificate chains detected ($CERT_COUNT chains)"
            echo "This will cause Google Play to reject the AAB."
            echo ""
            echo "Full verification output:"
            cat /tmp/jarsigner_output.txt
            exit 1
          elif [ "$CERT_COUNT" -eq 1 ]; then
            echo "‚úÖ Single certificate chain confirmed"
          else
            echo "‚ö†Ô∏è WARNING: Could not determine certificate chain count"
          fi
          
          echo ""
          echo "‚úÖ AAB signature verified successfully"
          echo "   - No debug certificate ‚úì"
          echo "   - Release certificate present ‚úì"
          echo "   - Single certificate chain ‚úì"
          echo ""
          echo "Certificate details:"
          grep -A 5 "Certificate chain\|Signed by" /tmp/jarsigner_output.txt | head -30 || cat /tmp/jarsigner_output.txt | head -50

      - name: üöÄ Upload to Google Play Internal Testing
        working-directory: android
        run: bundle exec fastlane upload_internal
        env:
          SUPPLY_JSON_KEY: ./fastlane/google-play-service-account.json

      - name: üì§ Upload Android artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: android-release-aab
          path: android/app/build/outputs/bundle/release/app-release.aab
          retention-days: 30

      - name: ‚úÖ Android deployment success
        if: success()
        run: |
          echo "‚úÖ Android app successfully deployed to Google Play Internal Testing!"
          echo "üì± Go to Google Play Console to test: https://play.google.com/console/"

  # ==========================================
  # JOB iOS - Build et Deploy sur TestFlight
  # ==========================================
  deploy-ios:
    name: üçé iOS ‚Üí TestFlight
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.platform == 'ios' || github.event.inputs.platform == 'both'))
    runs-on: macos-15  # macOS 15 has Xcode 16.x

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üì¶ Install dependencies (excluding dev dependencies for Release)
        run: npm ci --omit=dev

      - name: üîß Select Xcode 16.1
        run: |
          sudo xcode-select -s /Applications/Xcode_16.1.app/Contents/Developer
          xcodebuild -version

      - name: üî® Generate iOS native folder
        run: npx expo prebuild --platform ios --clean

      - name: üîß Fix iOS nullability issues
        run: |
          chmod +x scripts/fix-ios-nullability.sh
          bash scripts/fix-ios-nullability.sh

      - name: üîß Set iOS deployment target in Xcode project
        run: |
          # Find the Xcode project file dynamically
          PROJECT_FILE=$(find ios -name "project.pbxproj" -type f | head -n 1)
          if [ -n "$PROJECT_FILE" ]; then
            echo "üì± Found Xcode project at: $PROJECT_FILE"
            sed -i '' 's/IPHONEOS_DEPLOYMENT_TARGET = [^;]*/IPHONEOS_DEPLOYMENT_TARGET = 13.4/g' "$PROJECT_FILE"
            echo "‚úÖ Set IPHONEOS_DEPLOYMENT_TARGET to 13.4"
            # Verify the change
            echo "üîç Verification:"
            grep "IPHONEOS_DEPLOYMENT_TARGET" "$PROJECT_FILE" | head -n 3
          else
            echo "‚ö†Ô∏è Warning: Could not find Xcode project.pbxproj file"
            exit 1
          fi

      - name: üíé Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: üßπ Clean Xcode Derived Data
        run: rm -rf ~/Library/Developer/Xcode/DerivedData

      - name: üîß Configure Podfile build settings
        working-directory: ios
        run: |
          echo "üîß Adding custom build settings to Podfile post_install hook"

          # Insert custom build settings into the existing post_install hook
          sed -i '' '/post_install do |installer|/a\
          \  # Custom build settings\
          \  installer.pods_project.targets.each do |target|\
          \    target.build_configurations.each do |config|\
          \      config.build_settings["IPHONEOS_DEPLOYMENT_TARGET"] = "13.4"\
          \      config.build_settings["GCC_WARN_INHIBIT_ALL_WARNINGS"] = "YES"\
          \      config.build_settings["SWIFT_SUPPRESS_WARNINGS"] = "YES"\
          \    end\
          \  end\
          ' Podfile

          echo "‚úÖ Podfile configured"

      - name: üì¶ Install CocoaPods dependencies
        working-directory: ios
        run: |
          pod install
          echo "‚úÖ CocoaPods dependencies installed"

      - name: üîß Set deployment target for all Pods
        run: |
          cd ios
          echo "Setting IPHONEOS_DEPLOYMENT_TARGET for all Pods to 13.4"
          find Pods -name "project.pbxproj" -type f | while read -r file; do
            sed -i '' 's/IPHONEOS_DEPLOYMENT_TARGET = [^;]*/IPHONEOS_DEPLOYMENT_TARGET = 13.4/g' "$file"
          done
          echo "‚úÖ All Pods deployment targets updated"

      - name: üîß Disable Swift 6 strict concurrency checking
        run: |
          PROJECT_FILE=$(find ios -name "project.pbxproj" -type f | head -n 1)
          if [ -n "$PROJECT_FILE" ]; then
            echo "üì± Disabling strict concurrency checking in: $PROJECT_FILE"
            awk '/buildSettings = \{/ {print; print "\t\t\t\tSWIFT_STRICT_CONCURRENCY = minimal;"; next}1' "$PROJECT_FILE" > "$PROJECT_FILE.tmp"
            mv "$PROJECT_FILE.tmp" "$PROJECT_FILE"
            echo "‚úÖ Swift strict concurrency checking disabled"
          fi

      - name: üîê Setup App Store Connect API Key
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          set -euo pipefail
          
          mkdir -p ios/fastlane/keys
          
          # D√©coder et cr√©er le fichier .p8
          echo "${{ secrets.APP_STORE_CONNECT_KEY_BASE64 }}" | base64 -d > ios/fastlane/keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8
          chmod 600 ios/fastlane/keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8
          
          # Cr√©er api_key.json avec la cl√© inline (format requis par fastlane/spaceship)
          python3 <<PY
          import json
          import os
          
          key_id = os.environ['APP_STORE_CONNECT_KEY_ID']
          issuer_id = os.environ['APP_STORE_CONNECT_ISSUER_ID']
          
          # Lire la cl√© priv√©e depuis le fichier
          with open(f'ios/fastlane/keys/AuthKey_{key_id}.p8', 'r', encoding='utf-8') as f:
              key_content = f.read().strip()
          
          # Cr√©er le dictionnaire JSON
          api_key_data = {
              "key_id": key_id,
              "issuer_id": issuer_id,
              "key": key_content,
              "in_house": False
          }
          
          # √âcrire le fichier JSON
          with open('ios/fastlane/keys/api_key.json', 'w', encoding='utf-8') as f:
              json.dump(api_key_data, f, indent=2)
          
          print("‚úÖ api_key.json created successfully")
          PY
          
          echo "‚úÖ App Store Connect API Key configured"

      - name: üìú Setup Match certificates
        working-directory: ios
        env:
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD: ${{ secrets.FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail
          
          echo "üîç Verifying Matchfile..."
          if [ ! -f "fastlane/Matchfile" ]; then
            echo "‚ùå ERROR: Matchfile not found at fastlane/Matchfile"
            exit 1
          fi
          
          echo "üìã Matchfile content:"
          cat fastlane/Matchfile
          echo ""
          
          # Verify app_identifier is present
          if ! grep -q "app_identifier" fastlane/Matchfile; then
            echo "‚ùå ERROR: app_identifier not found in Matchfile"
            exit 1
          fi
          
          # Verify api_key.json exists
          if [ ! -f "fastlane/keys/api_key.json" ]; then
            echo "‚ùå ERROR: api_key.json not found at fastlane/keys/api_key.json"
            exit 1
          fi
          
          echo "‚úÖ Matchfile and api_key.json verified"
          echo ""
          echo "üîê Running match..."
          bundle exec fastlane match appstore --readonly

      - name: üöÄ Build and Deploy to TestFlight
        working-directory: ios
        run: bundle exec fastlane beta
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          # Configuration TestFlight - Groupes de testeurs
          # Format: "Internal Testers,QA Team,Beta Testers" (s√©par√©s par des virgules)
          # Laisse vide pour distribuer √† tous les testeurs internes
          TESTFLIGHT_GROUPS: ${{ secrets.TESTFLIGHT_GROUPS || '' }}
          # Distribution aux testeurs externes (true/false)
          TESTFLIGHT_DISTRIBUTE_EXTERNAL: ${{ secrets.TESTFLIGHT_DISTRIBUTE_EXTERNAL || 'false' }}
          # Notifier les testeurs externes (true/false)
          TESTFLIGHT_NOTIFY_EXTERNAL: ${{ secrets.TESTFLIGHT_NOTIFY_EXTERNAL || 'false' }}
          # Description pour les testeurs (optionnel)
          TESTFLIGHT_BETA_DESCRIPTION: ${{ secrets.TESTFLIGHT_BETA_DESCRIPTION || 'Nouvelle version de Maya disponible pour test' }}
          # Informations de contact pour la review (requis si distribute_external: true)
          TESTFLIGHT_CONTACT_EMAIL: ${{ secrets.TESTFLIGHT_CONTACT_EMAIL || secrets.FASTLANE_APPLE_ID }}
          TESTFLIGHT_CONTACT_FIRST_NAME: ${{ secrets.TESTFLIGHT_CONTACT_FIRST_NAME || 'Maya' }}
          TESTFLIGHT_CONTACT_LAST_NAME: ${{ secrets.TESTFLIGHT_CONTACT_LAST_NAME || 'Team' }}
          TESTFLIGHT_CONTACT_PHONE: ${{ secrets.TESTFLIGHT_CONTACT_PHONE || '' }}
          TESTFLIGHT_DEMO_ACCOUNT: ${{ secrets.TESTFLIGHT_DEMO_ACCOUNT || '' }}
          TESTFLIGHT_DEMO_PASSWORD: ${{ secrets.TESTFLIGHT_DEMO_PASSWORD || '' }}
          TESTFLIGHT_REVIEW_NOTES: ${{ secrets.TESTFLIGHT_REVIEW_NOTES || 'Application de test pour Maya' }}

      - name: üì§ Upload iOS artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ios-release-ipa
          path: ios/*.ipa
          retention-days: 30

      - name: ‚úÖ iOS deployment success
        if: success()
        run: |
          echo "‚úÖ iOS app successfully deployed to TestFlight!"
          echo "üì± Go to App Store Connect to test: https://appstoreconnect.apple.com/"

  # ==========================================
  # JOB NOTIFICATION - R√©sum√© final
  # ==========================================
  notify-success:
    name: üì¢ Deployment Summary
    needs: [deploy-android, deploy-ios]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: üìä Deployment Summary
        run: |
          echo "======================================"
          echo "üéâ DEPLOYMENT COMPLETED"
          echo "======================================"
          echo ""
          echo "Android Status: ${{ needs.deploy-android.result }}"
          echo "iOS Status: ${{ needs.deploy-ios.result }}"
          echo ""
          if [ "${{ needs.deploy-android.result }}" == "success" ]; then
            echo "‚úÖ Android: https://play.google.com/console/"
          fi
          if [ "${{ needs.deploy-ios.result }}" == "success" ]; then
            echo "‚úÖ iOS: https://appstoreconnect.apple.com/"
          fi
          echo ""
          echo "======================================"